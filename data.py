# -*- coding: utf-8 -*-
"""data.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/13QLLGKCncwBXHF_D5RzYqOn9xEkEY6c0
"""

from torchvision.datasets import VisionDataset, CIFAR100
from torch.nn import functional as F
import torchvision.transforms.functional as TF
from torchvision import transforms
from torch.utils.data import DataLoader
import torch
import numpy as np
import random

seed=17
random.seed(seed)

class Cifar100(VisionDataset):
  def __init__(self, root, train, transform=None, target_transform=None):
    super(Cifar100, self).__init__(root, transform=transform, target_transform=target_transform)

    self.dataset = CIFAR100(root=root, train=train, download=True, transform=None)
    self.transform = transform
    self.pixel_mean, self.pixel_std = self.__meanStd__(root)

    # Define shuffled classes
    self.shuffled_classes = self.__shuffled__()

    #Create mapping of shuffled classes
    self.label_map = {k: v for v, k in enumerate(self.shuffled_classes)}

    # Define classes per batch starting from shuffled_classes (e.g. class_batches[0]=[3,99,53,21,70,...])
    self.class_batches = self.__classPerBatch__()
    
    # Dictionary with key=batch number, value=list
    # The batch number refers to class_batches, while the list contains the indexes of images of the dataset that have a label in that specific batch_class
    self.batch_indexes = self.__createBatchIndexes__()

  def __shuffled__(self):
    seed=17
    num_classes=100
    all_classes=np.linspace(0, num_classes-1, num_classes)
    rng = np.random.default_rng(seed)
    shuf = rng.choice(all_classes, size=num_classes, replace=False).astype(int).tolist()
    return shuf

  def __meanStd__(self,root):
    dataset = CIFAR100(root=root,train=True,transform=transforms.ToTensor())
    loader = DataLoader(dataset, batch_size=1024, num_workers=2)
    channels_sum, channels_sqrd_sum, num_batches = 0, 0, 0
    for images, _ in loader: #Size([1 or 1024, 3, 32, 32])
      channels_sum += torch.mean(images, dim=[0])
      channels_sqrd_sum += torch.mean(images ** 2, dim=[0])
      num_batches += 1
    mean = channels_sum / num_batches
    # var[X] = E[X**2] - E[X]**2
    std = (channels_sqrd_sum / num_batches - mean ** 2) ** 0.5
    return mean, std

  def __classPerBatch__(self):
    batches=dict.fromkeys(np.arange(10)) #{0: None, ..., 9: None}
    for i in range(10):
      # batches[0]=[list of 10 classes], batches[1]=[other ten classes], ...
      batches[i] = self.shuffled_classes[i*10:(i*10+10)] 
    return batches

  def __createBatchIndexes__(self):
    batches = dict.fromkeys(np.arange(10))
    #Set value for each batch to empty list
    for i in range(10):
      batches[i] = []
    #iterate on items in dataset
    for idx,item in enumerate(self.dataset):
      #iterate over each batch (10)
      #check label value of item of dataset (item[1]) and assign its index to the correct batch
      #e.g. first batch is [2,..,], so if item[1]=2 then I append the idx of item to the list of elements associated to first batch  
      for i in range(10):
        if item[1] in self.class_batches[i]:
          batches[i].append(idx)
    return batches

  def __BatchIndexes__(self,batch_index):
    return self.batch_indexes[batch_index]

  def __incrementalBatchIndexes(self,stop_batch_index):
    list=[]
    for i in range(stop_batch_index):
      list=list+self.batch_indexes[i]
    return list

  def __getitem__(self, index):
    image, label = self.dataset[index]
    if self.transform is not None:
      image = self.transform(image)
      #normalise
      image -= self.pixel_mean/self.pixel_std  #Here I added division by std, could be useful?
    return image, self.label_map[label]

  def __len__(self):
    return len(self.dataset)

def augmentate(image):
  
  #81.8% evaluate  
  num=np.random.randint(0,4) #if I get 0 do nothing
  if num==1:
    if np.random.randint(2):
      image = TF.adjust_brightness(image, random.uniform(0, 2))
  if num==2:
    if np.random.randint(2):
      image = TF.adjust_contrast(image, random.uniform(0, 2))
  if num==3:
    if np.random.randint(2):
      image = TF.adjust_saturation(image, random.uniform(0, 2)) 
  if num==4:
    if np.random.randint(2):
      image = TF.adjust_hue(image, random.uniform(-0.5, 0.5))
  
  image = F.pad(image,(4,4,4,4),value=0)
  x, y = np.random.randint(8), np.random.randint(8) #pad=4 => max(x)=8
  image = image[:,x:x+32,y:y+32]
  if np.random.randint(2): #if random number is 1 then flip
    image = torch.flip(image,[2])
  return image
  #https://pytorch.org/vision/stable/transforms.html
  

  
  
  #Inspo from https://github.com/NiccoloCavagnero/IncrementalLearning/blob/master/dataset.py